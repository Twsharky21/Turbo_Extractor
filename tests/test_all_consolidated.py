"""Consolidated Turbo Extractor V3 test suite.

Auto-generated by merging previously passing test modules into a single file.
"""


# ==================== BEGIN test_core_consolidated.py ====================

# Consolidated from: test_io_basic.py, test_parsing.py, test_rules_basic.py, test_transform_basic.py, test_planner_landing_zone_append.py, test_writer_basic.py, test_errors.py
# Generated: 2026-02-19 20:40 UTC
# NOTE: Function renames applied only to avoid name collisions across original test modules.



# ---- BEGIN test_io_basic.py ----

\
from core.io import is_occupied, normalize_table, compute_used_range


def test_is_occupied():
    assert not is_occupied(None)
    assert not is_occupied("")
    assert is_occupied(" ")
    assert is_occupied(0)
    assert is_occupied("text")


def test_normalize_table():
    rows = [[1, 2], [3]]
    norm = normalize_table(rows)
    assert len(norm[1]) == 2
    assert norm[1][1] is None


def test_compute_used_range_basic():
    rows = [
        [None, None],
        [None, 5],
        [None, None],
    ]
    h, w = compute_used_range(rows)
    assert h == 2
    assert w == 2


# ---- END {f} ----



# ---- BEGIN test_parsing.py ----

\
import pytest

from core.errors import AppError, BAD_SPEC
from core.parsing import (
    col_letters_to_index,
    col_index_to_letters,
    parse_columns,
    parse_rows,
)


def test_col_letters_to_index_basic():
    assert col_letters_to_index("A") == 1
    assert col_letters_to_index("Z") == 26
    assert col_letters_to_index("AA") == 27
    assert col_letters_to_index("AZ") == 52
    assert col_letters_to_index("BA") == 53


def test_col_index_to_letters_basic():
    assert col_index_to_letters(1) == "A"
    assert col_index_to_letters(26) == "Z"
    assert col_index_to_letters(27) == "AA"
    assert col_index_to_letters(52) == "AZ"
    assert col_index_to_letters(53) == "BA"


def test_col_roundtrip_property_small():
    for n in range(1, 200):
        assert col_letters_to_index(col_index_to_letters(n)) == n


def test_parse_columns_blank_means_all_by_caller():
    assert parse_columns("") == []
    assert parse_columns("   ") == []


def test_parse_columns_singletons_and_ranges_unique_sorted():
    assert parse_columns("A,C") == [0, 2]
    assert parse_columns("C,A") == [0, 2]
    assert parse_columns("A-C") == [0, 1, 2]
    assert parse_columns("A-C,C,A") == [0, 1, 2]


def test_parse_columns_whitespace_and_trailing_commas():
    assert parse_columns(" A, C, ") == [0, 2]
    cols = parse_columns("A, C, AC-AE,")
    assert cols[0] == 0
    assert 2 in cols


def test_parse_columns_reverse_range_normalizes():
    assert parse_columns("D-B") == [1, 2, 3]


def test_parse_columns_rejects_bad_tokens():
    with pytest.raises(AppError) as ei:
        parse_columns("A,??,C")
    assert ei.value.code == BAD_SPEC


def test_parse_rows_blank_means_all_by_caller():
    assert parse_rows("") == []
    assert parse_rows("   ") == []


def test_parse_rows_singletons_and_ranges_unique_sorted():
    assert parse_rows("1,3") == [0, 2]
    assert parse_rows("3,1") == [0, 2]
    assert parse_rows("1-3") == [0, 1, 2]
    assert parse_rows("1-3,3-5,10,12-13") == [0, 1, 2, 3, 4, 9, 11, 12]


def test_parse_rows_whitespace_and_trailing_commas():
    assert parse_rows(" 1 , 2-3, ") == [0, 1, 2]


def test_parse_rows_reverse_range_normalizes():
    assert parse_rows("6-4") == [3, 4, 5]


def test_parse_rows_rejects_bad_tokens():
    with pytest.raises(AppError) as ei:
        parse_rows("1,2,nope")
    assert ei.value.code == BAD_SPEC


def test_parse_rows_rejects_nonpositive():
    with pytest.raises(AppError):
        parse_rows("0")
    with pytest.raises(AppError):
        parse_rows("-1")
    with pytest.raises(AppError):
        parse_rows("1-0")


# ---- END {f} ----



# ---- BEGIN test_rules_basic.py ----

\
from core.rules import apply_rules
from core.models import Rule


def rules_sample_rows():
    return [
        ["alpha", "10"],
        ["beta", "20"],
        ["gamma", "30"],
        ["beta", "5"],
        ["", None],
    ]


def test_include_equals():
    rows = rules_sample_rows()
    rules = [Rule(mode="include", column="A", operator="equals", value="beta")]
    result = apply_rules(rows, rules, "AND")
    assert len(result) == 2


def test_exclude_equals():
    rows = rules_sample_rows()
    rules = [Rule(mode="exclude", column="A", operator="equals", value="beta")]
    result = apply_rules(rows, rules, "AND")
    assert len(result) == 3


def test_contains_case_insensitive():
    rows = rules_sample_rows()
    rules = [Rule(mode="include", column="A", operator="contains", value="ALP")]
    result = apply_rules(rows, rules, "AND")
    assert len(result) == 1


def test_numeric_greater_than():
    rows = rules_sample_rows()
    rules = [Rule(mode="include", column="B", operator=">", value="15")]
    result = apply_rules(rows, rules, "AND")
    assert len(result) == 2


def test_numeric_less_than_safe_on_non_numeric():
    rows = rules_sample_rows()
    rules = [Rule(mode="include", column="B", operator="<", value="15")]
    result = apply_rules(rows, rules, "AND")
    assert len(result) == 2


def test_and_combine():
    rows = rules_sample_rows()
    rules = [
        Rule(mode="include", column="A", operator="equals", value="beta"),
        Rule(mode="include", column="B", operator=">", value="10"),
    ]
    result = apply_rules(rows, rules, "AND")
    assert len(result) == 1


def test_or_combine():
    rows = rules_sample_rows()
    rules = [
        Rule(mode="include", column="A", operator="equals", value="alpha"),
        Rule(mode="include", column="B", operator=">", value="25"),
    ]
    result = apply_rules(rows, rules, "OR")
    assert len(result) == 2


# ---- END {f} ----



# ---- BEGIN test_transform_basic.py ----

\
from core.transform import (
    apply_row_selection,
    apply_column_selection,
    shape_pack,
    shape_keep,
)


def transform_sample_rows():
    return [
        ["A1", "B1", "C1", "D1"],
        ["A2", "B2", "C2", "D2"],
        ["A3", "B3", "C3", "D3"],
        ["A4", "B4", "C4", "D4"],
    ]


def test_row_selection_basic():
    rows = transform_sample_rows()
    result = apply_row_selection(rows, [0, 2])
    assert len(result) == 2
    assert result[1][0] == "A3"


def test_column_selection_basic():
    rows = transform_sample_rows()
    result = apply_column_selection(rows, [0, 2])
    assert result[0] == ["A1", "C1"]


def test_pack_mode_identity():
    rows = transform_sample_rows()
    packed = shape_pack(rows)
    assert packed == rows


def test_keep_mode_preserves_spacing():
    rows = transform_sample_rows()
    selected_rows = [0, 2]
    selected_cols = [0, 2]

    shaped = shape_keep(rows, selected_rows, selected_cols)

    # bounding box: rows 0-2, cols 0-2
    assert len(shaped) == 3
    assert len(shaped[0]) == 3

    # row 1 should be blank (not selected)
    assert shaped[1] == [None, None, None]

    # selected positions preserved
    assert shaped[0][0] == "A1"
    assert shaped[0][2] == "C1"
    assert shaped[2][0] == "A3"
    assert shaped[2][2] == "C3"


# ---- END {f} ----



# ---- BEGIN test_planner_landing_zone_append.py ----

\
import pytest
from openpyxl import Workbook

from core.planner import build_plan
from core.errors import AppError, DEST_BLOCKED


def make_ws_with_values():
    wb = Workbook()
    ws = wb.active
    ws.title = "Sheet1"
    return wb, ws


def test_append_uses_max_used_row_across_landing_cols():
    wb, ws = make_ws_with_values()

    # Landing zone will be D:E (start_col=D, width=2)
    ws["D5"] = "x"
    ws["E10"] = "y"
    # This must NOT affect landing-zone aware append:
    ws["A100"] = "zzz"

    shaped = [["a", "b"], ["c", "d"]]  # height=2, width=2
    plan = build_plan(ws, shaped, start_col_letters="D", start_row_str="")

    assert plan is not None
    assert plan.start_row == 11  # max used row across D/E is 10 -> append at 11
    assert plan.start_col == 4   # D
    assert plan.landing_cols == (4, 5)
    assert plan.landing_rows == (11, 12)


def test_append_skips_past_any_used_cells_in_landing_zone():
    wb, ws = make_ws_with_values()

    # D/E landing zone, width=2
    ws["D3"] = "x"
    ws["E4"] = "BLOCK"

    shaped = [["a", "b"], ["c", "d"]]  # height=2, width=2

    # Full landing-zone awareness means append after the max used row across D/E (which is 4)
    plan = build_plan(ws, shaped, start_col_letters="D", start_row_str="")
    assert plan is not None
    assert plan.start_row == 5  # max used row across D/E is 4 -> append at 5


def test_explicit_start_row_collision_probe_blocks():
    wb, ws = make_ws_with_values()

    ws["D50"] = "BLOCK"
    shaped = [["a", "b"]]

    with pytest.raises(AppError) as ei:
        build_plan(ws, shaped, start_col_letters="D", start_row_str="50")

    assert ei.value.code == DEST_BLOCKED
    assert ei.value.details["target_start"] == "D50"


# ---- END {f} ----



# ---- BEGIN test_writer_basic.py ----

\
from openpyxl import Workbook

from core.planner import build_plan
from core.writer import apply_write_plan


def test_writer_writes_exact_rectangle():
    wb = Workbook()
    ws = wb.active

    shaped = [
        ["a", "b"],
        ["c", "d"],
    ]

    plan = build_plan(ws, shaped, start_col_letters="C", start_row_str="")
    rows_written = apply_write_plan(ws, shaped, plan)

    assert rows_written == 2
    assert ws["C1"].value == "a"
    assert ws["D1"].value == "b"
    assert ws["C2"].value == "c"
    assert ws["D2"].value == "d"


def test_writer_appends_after_existing_data():
    wb = Workbook()
    ws = wb.active

    ws["C1"] = "existing"
    ws["D3"] = "also existing"

    shaped = [
        ["x", "y"],
    ]

    plan = build_plan(ws, shaped, start_col_letters="C", start_row_str="")
    apply_write_plan(ws, shaped, plan)

    # max used row across C:D is 3 -> append at row 4
    assert ws["C4"].value == "x"
    assert ws["D4"].value == "y"


# ---- END {f} ----



# ---- BEGIN test_errors.py ----

\
from core.errors import AppError


def test_app_error_str_includes_code_message():
    e = AppError("X", "Nope")
    assert str(e).startswith("X: Nope")


def test_app_error_str_includes_details_when_present():
    e = AppError("X", "Nope", {"a": 1})
    s = str(e)
    assert "X: Nope" in s
    assert "a" in s


# ---- END {f} ----

# ==================== END test_core_consolidated.py ====================



# ==================== BEGIN test_engine_consolidated.py ====================

# Consolidated from: test_engine_smoke.py, test_engine_more.py
# Generated: 2026-02-19 20:40 UTC
# NOTE: Function renames applied only to avoid name collisions across original test modules.



# ---- BEGIN test_engine_smoke.py ----

\
import os
from tempfile import TemporaryDirectory
from openpyxl import Workbook, load_workbook

from core.engine import run_sheet
from core.models import SheetConfig, Destination, Rule


def smoke_make_source_xlsx(path: str):
    wb = Workbook()
    ws = wb.active
    ws.title = "Sheet1"
    # 4 cols x 4 rows
    data = [
        ["alpha", "x", 1, "foo"],
        ["beta",  "y", 2, "bar"],
        ["gamma", "z", 3, "baz"],
        ["beta",  "y", 4, "qux"],
    ]
    for r, row in enumerate(data, start=1):
        for c, val in enumerate(row, start=1):
            ws.cell(row=r, column=c, value=val)
    wb.save(path)


def test_engine_smoke_pack_columns_and_rules_and_append():
    with TemporaryDirectory() as td:
        src = os.path.join(td, "src.xlsx")
        dest = os.path.join(td, "dest.xlsx")

        smoke_make_source_xlsx(src)

        # Pre-populate destination in landing columns B:C to force append to row 2
        wb = Workbook()
        ws = wb.active
        ws.title = "Out"
        ws["B1"] = "existing"
        ws["C1"] = "existing2"
        wb.save(dest)

        cfg = SheetConfig(
            name="Sheet1",
            workbook_sheet="Sheet1",
            columns_spec="A,C",   # take alpha/beta/gamma + numeric col
            rows_spec="",         # ALL used
            paste_mode="pack",
            rules_combine="AND",
            rules=[Rule(mode="include", column="A", operator="equals", value="beta")],
            destination=Destination(
                file_path=dest,
                sheet_name="Out",
                start_col="B",
                start_row="",       # append mode (landing-zone aware)
            ),
        )

        result = run_sheet(src, cfg, recipe_name="R1")
        assert result.rows_written == 2

        out = load_workbook(dest)
        ws = out["Out"]

        # Append should be at row 2 (since max used row in B:C was 1)
        assert ws["B2"].value == "beta"
        assert ws["C2"].value == 2
        assert ws["B3"].value == "beta"
        assert ws["C3"].value == 4


# ---- END {f} ----



# ---- BEGIN test_engine_more.py ----

\
import os
import csv
import pytest
from tempfile import TemporaryDirectory
from openpyxl import Workbook, load_workbook

from core.engine import run_sheet
from core.models import SheetConfig, Destination, Rule
from core.errors import AppError, DEST_BLOCKED


def more_make_source_xlsx(path: str):
    wb = Workbook()
    ws = wb.active
    ws.title = "Sheet1"
    data = [
        ["alpha", "x", 1, "foo"],
        ["beta",  "y", 2, "bar"],
        ["gamma", "z", 3, "baz"],
        ["beta",  "y", 4, "qux"],
    ]
    for r, row in enumerate(data, start=1):
        for c, val in enumerate(row, start=1):
            ws.cell(row=r, column=c, value=val)
    wb.save(path)


def more_make_source_csv(path: str):
    data = [
        ["alpha", "x", 1, "foo"],
        ["beta",  "y", 2, "bar"],
        ["gamma", "z", 3, "baz"],
        ["beta",  "y", 4, "qux"],
    ]
    with open(path, "w", newline="", encoding="utf-8") as f:
        w = csv.writer(f)
        for row in data:
            w.writerow(row)


def read_cells(dest_path: str, sheet: str, addr_list):
    wb = load_workbook(dest_path)
    ws = wb[sheet]
    return [ws[a].value for a in addr_list]


def test_engine_csv_smoke_pack_rules_append():
    with TemporaryDirectory() as td:
        src = os.path.join(td, "src.csv")
        dest = os.path.join(td, "dest.xlsx")

        more_make_source_csv(src)

        wb = Workbook()
        ws = wb.active
        ws.title = "Out"
        ws["B1"] = "existing"
        ws["C1"] = "existing2"
        wb.save(dest)

        cfg = SheetConfig(
            name="Sheet1",
            workbook_sheet="Sheet1",  # ignored for CSV
            columns_spec="A,C",
            rows_spec="",
            paste_mode="pack",
            rules_combine="AND",
            rules=[Rule(mode="include", column="A", operator="equals", value="beta")],
            destination=Destination(file_path=dest, sheet_name="Out", start_col="B", start_row=""),
        )

        result = run_sheet(src, cfg, recipe_name="R1")
        assert result.rows_written == 2

        vals = read_cells(dest, "Out", ["B2", "C2", "B3", "C3"])
        assert vals[0] == "beta"
        # CSV numeric may be string "2"
        assert vals[1] in (2, "2")
        assert vals[2] == "beta"
        assert vals[3] in (4, "4")


def test_engine_keep_mode_preserves_gaps_no_rules():
    with TemporaryDirectory() as td:
        src = os.path.join(td, "src.xlsx")
        dest = os.path.join(td, "dest.xlsx")
        more_make_source_xlsx(src)

        cfg = SheetConfig(
            name="Sheet1",
            workbook_sheet="Sheet1",
            columns_spec="A,C",   # gap at B
            rows_spec="1,3",      # gap at row 2
            paste_mode="keep",
            rules_combine="AND",
            rules=[],
            destination=Destination(file_path=dest, sheet_name="Out", start_col="B", start_row="1"),
        )

        result = run_sheet(src, cfg, recipe_name="R1")
        assert result.rows_written == 3  # keep bounding box rows 1-3 => 3 rows

        wb = load_workbook(dest)
        ws = wb["Out"]

        # Output bounding box width=3 (A..C) mapped to start_col B => B..D
        # Row 1 has A1 and C1
        assert ws["B1"].value == "alpha"
        assert ws["C1"].value is None
        assert ws["D1"].value == 1

        # Row 2 (gap) should be all None
        assert ws["B2"].value is None
        assert ws["C2"].value is None
        assert ws["D2"].value is None

        # Row 3 has A3 and C3
        assert ws["B3"].value == "gamma"
        assert ws["C3"].value is None
        assert ws["D3"].value == 3


def test_engine_explicit_start_row_and_col_lands_exactly():
    with TemporaryDirectory() as td:
        src = os.path.join(td, "src.xlsx")
        dest = os.path.join(td, "dest.xlsx")
        more_make_source_xlsx(src)

        cfg = SheetConfig(
            name="Sheet1",
            workbook_sheet="Sheet1",
            columns_spec="A,C",
            rows_spec="1-2",
            paste_mode="pack",
            rules_combine="AND",
            rules=[],
            destination=Destination(file_path=dest, sheet_name="Out", start_col="D", start_row="50"),
        )

        result = run_sheet(src, cfg, recipe_name="R1")
        assert result.rows_written == 2

        wb = load_workbook(dest)
        ws = wb["Out"]
        assert ws["D50"].value == "alpha"
        assert ws["E50"].value == 1
        assert ws["D51"].value == "beta"
        assert ws["E51"].value == 2


def test_engine_dest_blocked_explicit_raises():
    with TemporaryDirectory() as td:
        src = os.path.join(td, "src.xlsx")
        dest = os.path.join(td, "dest.xlsx")
        more_make_source_xlsx(src)

        # Create destination with a blocker at the exact landing cell
        wb = Workbook()
        ws = wb.active
        ws.title = "Out"
        ws["D50"] = "BLOCK"
        wb.save(dest)

        cfg = SheetConfig(
            name="Sheet1",
            workbook_sheet="Sheet1",
            columns_spec="A,C",
            rows_spec="1-1",
            paste_mode="pack",
            rules_combine="AND",
            rules=[],
            destination=Destination(file_path=dest, sheet_name="Out", start_col="D", start_row="50"),
        )

        with pytest.raises(AppError) as ei:
            run_sheet(src, cfg, recipe_name="R1")
        assert ei.value.code == DEST_BLOCKED


def test_engine_append_two_runs_stack_by_landing_zone_cols():
    with TemporaryDirectory() as td:
        src = os.path.join(td, "src.xlsx")
        dest = os.path.join(td, "dest.xlsx")
        more_make_source_xlsx(src)

        cfg = SheetConfig(
            name="Sheet1",
            workbook_sheet="Sheet1",
            columns_spec="A,C",
            rows_spec="1-1",
            paste_mode="pack",
            rules_combine="AND",
            rules=[],
            destination=Destination(file_path=dest, sheet_name="Out", start_col="B", start_row=""),
        )

        r1 = run_sheet(src, cfg, recipe_name="R1")
        r2 = run_sheet(src, cfg, recipe_name="R1")
        assert r1.rows_written == 1
        assert r2.rows_written == 1

        wb = load_workbook(dest)
        ws = wb["Out"]
        assert ws["B1"].value == "alpha"
        assert ws["C1"].value == 1
        assert ws["B2"].value == "alpha"
        assert ws["C2"].value == 1


def test_engine_rules_filter_to_zero_rows_writes_nothing():
    with TemporaryDirectory() as td:
        src = os.path.join(td, "src.xlsx")
        dest = os.path.join(td, "dest.xlsx")
        more_make_source_xlsx(src)

        cfg = SheetConfig(
            name="Sheet1",
            workbook_sheet="Sheet1",
            columns_spec="A,C",
            rows_spec="",
            paste_mode="pack",
            rules_combine="AND",
            rules=[Rule(mode="include", column="A", operator="equals", value="NO_MATCH")],
            destination=Destination(file_path=dest, sheet_name="Out", start_col="B", start_row=""),
        )

        result = run_sheet(src, cfg, recipe_name="R1")
        assert result.rows_written == 0

        wb = load_workbook(dest)
        assert "Out" in wb.sheetnames
        ws = wb["Out"]
        # should remain empty
        assert ws["B1"].value in (None, "")


# ---- END {f} ----

# ==================== END test_engine_consolidated.py ====================



# ==================== BEGIN test_run_all_consolidated.py ====================

# Consolidated from: test_run_all.py, test_run_all_more.py, test_project_config.py
# Generated: 2026-02-19 20:40 UTC
# NOTE: Function renames applied only to avoid name collisions across original test modules.



# ---- BEGIN test_run_all.py ----

\
import os
from tempfile import TemporaryDirectory
from openpyxl import Workbook, load_workbook

from core.engine import run_all
from core.models import SheetConfig, Destination
from core.errors import DEST_BLOCKED


def runall_make_source_xlsx(path: str, sheet_name: str, tag: str):
    wb = Workbook()
    ws = wb.active
    ws.title = sheet_name
    ws["A1"] = f"{tag}-alpha"
    ws["B1"] = "x"
    ws["C1"] = 1
    wb.save(path)


def test_run_all_two_items_success_same_dest_stacks():
    with TemporaryDirectory() as td:
        src1 = os.path.join(td, "s1.xlsx")
        src2 = os.path.join(td, "s2.xlsx")
        dest = os.path.join(td, "out.xlsx")

        runall_make_source_xlsx(src1, "Sheet1", "S1")
        runall_make_source_xlsx(src2, "Sheet1", "S2")

        cfg1 = SheetConfig(
            name="Sheet1",
            workbook_sheet="Sheet1",
            columns_spec="A,C",
            rows_spec="1-1",
            paste_mode="pack",
            rules_combine="AND",
            rules=[],
            destination=Destination(file_path=dest, sheet_name="Out", start_col="B", start_row=""),
        )
        cfg2 = SheetConfig(
            name="Sheet1",
            workbook_sheet="Sheet1",
            columns_spec="A,C",
            rows_spec="1-1",
            paste_mode="pack",
            rules_combine="AND",
            rules=[],
            destination=Destination(file_path=dest, sheet_name="Out", start_col="B", start_row=""),
        )

        report = run_all([
            (src1, "R1", cfg1),
            (src2, "R2", cfg2),
        ])

        assert report.ok is True
        assert len(report.results) == 2
        assert report.results[0].rows_written == 1
        assert report.results[1].rows_written == 1

        wb = load_workbook(dest)
        ws = wb["Out"]
        assert ws["B1"].value == "S1-alpha"
        assert ws["C1"].value == 1
        assert ws["B2"].value == "S2-alpha"
        assert ws["C2"].value == 1


def test_run_all_fail_fast_records_error_and_stops():
    with TemporaryDirectory() as td:
        src1 = os.path.join(td, "s1.xlsx")
        src2 = os.path.join(td, "s2.xlsx")
        dest = os.path.join(td, "out.xlsx")

        runall_make_source_xlsx(src1, "Sheet1", "S1")
        runall_make_source_xlsx(src2, "Sheet1", "S2")

        wb = Workbook()
        ws = wb.active
        ws.title = "Out"
        ws["B1"] = "BLOCK"
        wb.save(dest)

        cfg_blocked = SheetConfig(
            name="Sheet1",
            workbook_sheet="Sheet1",
            columns_spec="A,C",
            rows_spec="1-1",
            paste_mode="pack",
            rules_combine="AND",
            rules=[],
            destination=Destination(file_path=dest, sheet_name="Out", start_col="B", start_row="1"),
        )

        cfg_should_not_run = SheetConfig(
            name="Sheet1",
            workbook_sheet="Sheet1",
            columns_spec="A,C",
            rows_spec="1-1",
            paste_mode="pack",
            rules_combine="AND",
            rules=[],
            destination=Destination(file_path=dest, sheet_name="Out", start_col="B", start_row=""),
        )

        report = run_all([
            (src1, "R1", cfg_blocked),
            (src2, "R2", cfg_should_not_run),
        ])

        assert report.ok is False
        assert len(report.results) == 1
        assert report.results[0].error_code == DEST_BLOCKED

        wb2 = load_workbook(dest)
        ws2 = wb2["Out"]
        values = [ws2["B1"].value, ws2["B2"].value, ws2["B3"].value]
        assert "S2-alpha" not in values


def test_run_all_progress_callback_events_success_order():
    from core.engine import run_all
    from core.models import SheetConfig, Destination

    events = []

    def cb(ev, payload):
        events.append((ev, payload))

    with TemporaryDirectory() as td:
        src1 = os.path.join(td, "s1.xlsx")
        src2 = os.path.join(td, "s2.xlsx")
        dest = os.path.join(td, "out.xlsx")

        runall_make_source_xlsx(src1, "Sheet1", "S1")
        runall_make_source_xlsx(src2, "Sheet1", "S2")

        cfg = SheetConfig(
            name="Sheet1",
            workbook_sheet="Sheet1",
            columns_spec="A,C",
            rows_spec="1-1",
            paste_mode="pack",
            rules_combine="AND",
            rules=[],
            destination=Destination(file_path=dest, sheet_name="Out", start_col="B", start_row=""),
        )

        report = run_all([(src1, "R1", cfg), (src2, "R2", cfg)], on_progress=cb)

        assert report.ok is True

        kinds = [e[0] for e in events]
        assert kinds[0:4] == ["start", "result", "start", "result"]
        assert kinds[-1] == "done"

        # result payloads are SheetResult
        assert getattr(events[1][1], "rows_written", None) == 1
        assert getattr(events[3][1], "rows_written", None) == 1


def test_run_all_progress_callback_events_fail_fast_order():
    from core.engine import run_all
    from core.models import SheetConfig, Destination

    events = []

    def cb(ev, payload):
        events.append((ev, payload))

    with TemporaryDirectory() as td:
        src1 = os.path.join(td, "s1.xlsx")
        src2 = os.path.join(td, "s2.xlsx")
        dest = os.path.join(td, "out.xlsx")

        runall_make_source_xlsx(src1, "Sheet1", "S1")
        runall_make_source_xlsx(src2, "Sheet1", "S2")

        wb = Workbook()
        ws = wb.active
        ws.title = "Out"
        ws["B1"] = "BLOCK"
        wb.save(dest)

        cfg_blocked = SheetConfig(
            name="Sheet1",
            workbook_sheet="Sheet1",
            columns_spec="A,C",
            rows_spec="1-1",
            paste_mode="pack",
            rules_combine="AND",
            rules=[],
            destination=Destination(file_path=dest, sheet_name="Out", start_col="B", start_row="1"),
        )
        cfg_should_not_run = SheetConfig(
            name="Sheet1",
            workbook_sheet="Sheet1",
            columns_spec="A,C",
            rows_spec="1-1",
            paste_mode="pack",
            rules_combine="AND",
            rules=[],
            destination=Destination(file_path=dest, sheet_name="Out", start_col="B", start_row=""),
        )

        report = run_all([(src1, "R1", cfg_blocked), (src2, "R2", cfg_should_not_run)], on_progress=cb)
        assert report.ok is False

        kinds = [e[0] for e in events]
        # Must stop after first error (no second start)
        assert kinds[0] == "start"
        assert "start" not in kinds[2:-1]
        assert kinds[1] == "error"
        assert kinds[-1] == "done"


# ---- END {f} ----



# ---- BEGIN test_run_all_more.py ----

\
import os
import csv
from tempfile import TemporaryDirectory
from openpyxl import Workbook, load_workbook

from core.engine import run_all
from core.models import SheetConfig, Destination, Rule
from core.errors import DEST_BLOCKED


def runall_more_make_source_xlsx(path: str, sheet_name: str, rows):
    wb = Workbook()
    ws = wb.active
    ws.title = sheet_name
    for r_idx, row in enumerate(rows, start=1):
        for c_idx, val in enumerate(row, start=1):
            ws.cell(row=r_idx, column=c_idx, value=val)
    wb.save(path)


def runall_more_make_source_csv(path: str, rows):
    with open(path, "w", newline="", encoding="utf-8") as f:
        w = csv.writer(f)
        for row in rows:
            w.writerow(row)


def test_run_all_three_items_stacks_rows_in_order_same_dest():
    with TemporaryDirectory() as td:
        dest = os.path.join(td, "out.xlsx")
        s1 = os.path.join(td, "s1.xlsx")
        s2 = os.path.join(td, "s2.xlsx")
        s3 = os.path.join(td, "s3.xlsx")

        runall_more_make_source_xlsx(s1, "Sheet1", [["A1", "x", 1]])
        runall_more_make_source_xlsx(s2, "Sheet1", [["A2", "x", 2]])
        runall_more_make_source_xlsx(s3, "Sheet1", [["A3", "x", 3]])

        cfg = lambda: SheetConfig(
            name="Sheet1",
            workbook_sheet="Sheet1",
            columns_spec="A,C",
            rows_spec="1-1",
            paste_mode="pack",
            rules_combine="AND",
            rules=[],
            destination=Destination(file_path=dest, sheet_name="Out", start_col="B", start_row=""),
        )

        report = run_all([
            (s1, "R1", cfg()),
            (s2, "R2", cfg()),
            (s3, "R3", cfg()),
        ])

        assert report.ok is True
        assert len(report.results) == 3

        wb = load_workbook(dest)
        ws = wb["Out"]
        assert ws["B1"].value == "A1"
        assert ws["C1"].value == 1
        assert ws["B2"].value == "A2"
        assert ws["C2"].value == 2
        assert ws["B3"].value == "A3"
        assert ws["C3"].value == 3


def test_run_all_mixed_widths_append_uses_full_landing_zone_awareness():
    with TemporaryDirectory() as td:
        dest = os.path.join(td, "out.xlsx")
        s1 = os.path.join(td, "s1.xlsx")
        s2 = os.path.join(td, "s2.xlsx")

        # s1 writes width=3 (A,B,C) -> landing zone B:D
        runall_more_make_source_xlsx(s1, "Sheet1", [["v1", "v2", "v3"]])
        # s2 writes width=2 (A,C) -> landing zone B:C
        runall_more_make_source_xlsx(s2, "Sheet1", [["w1", "x", "w3"]])

        cfg1 = SheetConfig(
            name="Sheet1",
            workbook_sheet="Sheet1",
            columns_spec="A,B,C",
            rows_spec="1-1",
            paste_mode="pack",
            rules_combine="AND",
            rules=[],
            destination=Destination(file_path=dest, sheet_name="Out", start_col="B", start_row=""),
        )
        cfg2 = SheetConfig(
            name="Sheet1",
            workbook_sheet="Sheet1",
            columns_spec="A,C",
            rows_spec="1-1",
            paste_mode="pack",
            rules_combine="AND",
            rules=[],
            destination=Destination(file_path=dest, sheet_name="Out", start_col="B", start_row=""),
        )

        report = run_all([
            (s1, "R1", cfg1),
            (s2, "R2", cfg2),
        ])
        assert report.ok is True

        wb = load_workbook(dest)
        ws = wb["Out"]
        # first row from cfg1 occupies B1:D1
        assert ws["B1"].value == "v1"
        assert ws["C1"].value == "v2"
        assert ws["D1"].value == "v3"
        # second run uses landing zone B:C; max used row across B:C is 1 => append at 2
        assert ws["B2"].value == "w1"
        assert ws["C2"].value == "w3"


def test_run_all_two_different_destinations_both_created():
    with TemporaryDirectory() as td:
        dest1 = os.path.join(td, "out1.xlsx")
        dest2 = os.path.join(td, "out2.xlsx")
        s1 = os.path.join(td, "s1.xlsx")
        s2 = os.path.join(td, "s2.xlsx")

        runall_more_make_source_xlsx(s1, "Sheet1", [["A1", "x", 1]])
        runall_more_make_source_xlsx(s2, "Sheet1", [["A2", "x", 2]])

        cfg1 = SheetConfig(
            name="Sheet1",
            workbook_sheet="Sheet1",
            columns_spec="A,C",
            rows_spec="1-1",
            paste_mode="pack",
            rules_combine="AND",
            rules=[],
            destination=Destination(file_path=dest1, sheet_name="Out", start_col="B", start_row=""),
        )
        cfg2 = SheetConfig(
            name="Sheet1",
            workbook_sheet="Sheet1",
            columns_spec="A,C",
            rows_spec="1-1",
            paste_mode="pack",
            rules_combine="AND",
            rules=[],
            destination=Destination(file_path=dest2, sheet_name="Out", start_col="B", start_row=""),
        )

        report = run_all([
            (s1, "R1", cfg1),
            (s2, "R2", cfg2),
        ])
        assert report.ok is True

        wb1 = load_workbook(dest1)
        wb2 = load_workbook(dest2)
        assert wb1["Out"]["B1"].value == "A1"
        assert wb2["Out"]["B1"].value == "A2"


def test_run_all_keep_mode_then_pack_mode_stacks():
    with TemporaryDirectory() as td:
        dest = os.path.join(td, "out.xlsx")
        s1 = os.path.join(td, "s1.xlsx")
        s2 = os.path.join(td, "s2.xlsx")

        # 3 rows so keep-mode bounding box height=3 when rows_spec=1,3
        runall_more_make_source_xlsx(s1, "Sheet1", [
            ["alpha", "x", 1],
            ["beta",  "y", 2],
            ["gamma", "z", 3],
        ])
        runall_more_make_source_xlsx(s2, "Sheet1", [["delta", "q", 9]])

        cfg_keep = SheetConfig(
            name="Sheet1",
            workbook_sheet="Sheet1",
            columns_spec="A,C",
            rows_spec="1,3",
            paste_mode="keep",
            rules_combine="AND",
            rules=[],
            destination=Destination(file_path=dest, sheet_name="Out", start_col="B", start_row=""),
        )
        cfg_pack = SheetConfig(
            name="Sheet1",
            workbook_sheet="Sheet1",
            columns_spec="A,C",
            rows_spec="1-1",
            paste_mode="pack",
            rules_combine="AND",
            rules=[],
            destination=Destination(file_path=dest, sheet_name="Out", start_col="B", start_row=""),
        )

        report = run_all([
            (s1, "R1", cfg_keep),
            (s2, "R2", cfg_pack),
        ])
        assert report.ok is True

        wb = load_workbook(dest)
        ws = wb["Out"]

        # keep run occupies B1:D3 (width=3, height=3)
        assert ws["B1"].value == "alpha"
        assert ws["D1"].value == 1
        assert ws["B2"].value is None
        assert ws["B3"].value == "gamma"
        assert ws["D3"].value == 3

        # pack run uses landing zone B:C; max used row across B:C is 3 => append at 4
        assert ws["B4"].value == "delta"
        assert ws["C4"].value == 9


def test_run_all_fail_fast_on_second_item_dest_blocked():
    with TemporaryDirectory() as td:
        dest = os.path.join(td, "out.xlsx")
        s1 = os.path.join(td, "s1.xlsx")
        s2 = os.path.join(td, "s2.xlsx")
        s3 = os.path.join(td, "s3.xlsx")

        runall_more_make_source_xlsx(s1, "Sheet1", [["A1", "x", 1]])
        runall_more_make_source_xlsx(s2, "Sheet1", [["A2", "x", 2]])
        runall_more_make_source_xlsx(s3, "Sheet1", [["A3", "x", 3]])

        cfg_ok = SheetConfig(
            name="Sheet1",
            workbook_sheet="Sheet1",
            columns_spec="A,C",
            rows_spec="1-1",
            paste_mode="pack",
            rules_combine="AND",
            rules=[],
            destination=Destination(file_path=dest, sheet_name="Out", start_col="B", start_row=""),
        )

        # Second item uses explicit start row that is blocked
        wb = Workbook()
        ws = wb.active
        ws.title = "Out"
        ws["B50"] = "BLOCK"
        wb.save(dest)

        cfg_blocked = SheetConfig(
            name="Sheet1",
            workbook_sheet="Sheet1",
            columns_spec="A,C",
            rows_spec="1-1",
            paste_mode="pack",
            rules_combine="AND",
            rules=[],
            destination=Destination(file_path=dest, sheet_name="Out", start_col="B", start_row="50"),
        )

        report = run_all([
            (s1, "R1", cfg_ok),
            (s2, "R2", cfg_blocked),
            (s3, "R3", cfg_ok),
        ])

        assert report.ok is False
        assert len(report.results) == 2
        assert report.results[1].error_code == DEST_BLOCKED

        wb2 = load_workbook(dest)
        ws2 = wb2["Out"]
        # Third item should not run
        colB = [ws2[f"B{i}"].value for i in range(1, 10)]
        assert "A3" not in colB


def test_run_all_csv_then_xlsx_same_dest_stacks():
    with TemporaryDirectory() as td:
        dest = os.path.join(td, "out.xlsx")
        s1 = os.path.join(td, "s1.csv")
        s2 = os.path.join(td, "s2.xlsx")

        runall_more_make_source_csv(s1, [["csv1", "x", 1]])
        runall_more_make_source_xlsx(s2, "Sheet1", [["xls1", "y", 2]])

        cfg_csv = SheetConfig(
            name="Sheet1",
            workbook_sheet="Sheet1",
            columns_spec="A,C",
            rows_spec="1-1",
            paste_mode="pack",
            rules_combine="AND",
            rules=[],
            destination=Destination(file_path=dest, sheet_name="Out", start_col="B", start_row=""),
        )
        cfg_xls = SheetConfig(
            name="Sheet1",
            workbook_sheet="Sheet1",
            columns_spec="A,C",
            rows_spec="1-1",
            paste_mode="pack",
            rules_combine="AND",
            rules=[],
            destination=Destination(file_path=dest, sheet_name="Out", start_col="B", start_row=""),
        )

        report = run_all([
            (s1, "R1", cfg_csv),
            (s2, "R2", cfg_xls),
        ])
        assert report.ok is True

        wb = load_workbook(dest)
        ws = wb["Out"]
        assert ws["B1"].value == "csv1"
        assert ws["C1"].value in (1, "1")
        assert ws["B2"].value == "xls1"
        assert ws["C2"].value == 2


def test_run_all_rules_filter_zero_rows_then_next_item_runs_and_writes():
    with TemporaryDirectory() as td:
        dest = os.path.join(td, "out.xlsx")
        s1 = os.path.join(td, "s1.xlsx")
        s2 = os.path.join(td, "s2.xlsx")

        runall_more_make_source_xlsx(s1, "Sheet1", [["alpha", "x", 1], ["beta", "y", 2]])
        runall_more_make_source_xlsx(s2, "Sheet1", [["gamma", "z", 3]])

        cfg_zero = SheetConfig(
            name="Sheet1",
            workbook_sheet="Sheet1",
            columns_spec="A,C",
            rows_spec="",
            paste_mode="pack",
            rules_combine="AND",
            rules=[Rule(mode="include", column="A", operator="equals", value="NO_MATCH")],
            destination=Destination(file_path=dest, sheet_name="Out", start_col="B", start_row=""),
        )
        cfg_write = SheetConfig(
            name="Sheet1",
            workbook_sheet="Sheet1",
            columns_spec="A,C",
            rows_spec="1-1",
            paste_mode="pack",
            rules_combine="AND",
            rules=[],
            destination=Destination(file_path=dest, sheet_name="Out", start_col="B", start_row=""),
        )

        report = run_all([
            (s1, "R1", cfg_zero),
            (s2, "R2", cfg_write),
        ])
        assert report.ok is True
        assert report.results[0].rows_written == 0
        assert report.results[1].rows_written == 1

        wb = load_workbook(dest)
        ws = wb["Out"]
        assert ws["B1"].value == "gamma"
        assert ws["C1"].value == 3


# ---- END {f} ----



# ---- BEGIN test_project_config.py ----

\
import os
from tempfile import TemporaryDirectory

from core.project import ProjectConfig, SourceConfig, RecipeConfig
from core.models import SheetConfig, Destination, Rule


def make_sample_project(dest_path: str):
    sheet = SheetConfig(
        name="Sheet1",
        workbook_sheet="Sheet1",
        columns_spec="A,C",
        rows_spec="1-1",
        paste_mode="pack",
        rules_combine="AND",
        rules=[Rule(mode="include", column="A", operator="equals", value="alpha")],
        destination=Destination(
            file_path=dest_path,
            sheet_name="Out",
            start_col="B",
            start_row="",
        ),
    )
    recipe = RecipeConfig(name="R1", sheets=[sheet])
    source = SourceConfig(path="dummy.xlsx", recipes=[recipe])
    return ProjectConfig(sources=[source])


def test_project_serialization_roundtrip():
    with TemporaryDirectory() as td:
        json_path = os.path.join(td, "proj.json")
        proj = make_sample_project("out.xlsx")

        proj.save_json(json_path)
        loaded = ProjectConfig.load_json(json_path)

        assert len(loaded.sources) == 1
        assert loaded.sources[0].recipes[0].name == "R1"
        assert loaded.sources[0].recipes[0].sheets[0].columns_spec == "A,C"


def test_project_build_run_items_order():
    proj = make_sample_project("out.xlsx")
    items = proj.build_run_items()

    assert len(items) == 1
    src_path, recipe_name, sheet = items[0]
    assert src_path == "dummy.xlsx"
    assert recipe_name == "R1"
    assert sheet.name == "Sheet1"


# ---- END {f} ----

# ==================== END test_run_all_consolidated.py ====================



# ==================== BEGIN test_gui_consolidated.py ====================

# Consolidated from: test_gui_importsafe.py, test_gui_project_wiring.py, test_gui_rules_ui.py, test_gui_sheet_editor.py, test_gui_tree_structure.py
# Generated: 2026-02-19 20:40 UTC
# NOTE: Function renames applied only to avoid name collisions across original test modules.



# ---- BEGIN test_gui_importsafe.py ----

\
def test_gui_module_import_safe():
    """
    Importing gui.app should NOT auto-launch Tkinter.
    We only check that the symbols exist and import succeeds.
    """
    import gui.app as app

    assert hasattr(app, "TurboExtractorApp")
    assert callable(app.main)


# ---- END {f} ----



# ---- BEGIN test_gui_project_wiring.py ----

\
def test_gui_import_and_project_attribute():
    import gui.app as app

    instance = app.TurboExtractorApp
    assert hasattr(instance, "__init__")

    # Ensure ProjectConfig attribute exists when instantiated (without mainloop)
    gui = instance()
    assert hasattr(gui, "project")
    gui.destroy()


# ---- END {f} ----



# ---- BEGIN test_gui_rules_ui.py ----

\
import gui.app as app
from core.project import ProjectConfig, SourceConfig, RecipeConfig
from core.models import SheetConfig, Destination


def test_add_rule_updates_model():
    gui = app.TurboExtractorApp()

    sheet = SheetConfig(
        name="Sheet1",
        workbook_sheet="Sheet1",
        columns_spec="",
        rows_spec="",
        paste_mode="pack",
        rules_combine="AND",
        rules=[],
        destination=Destination(
            file_path="",
            sheet_name="Sheet1",
            start_col="A",
            start_row="",
        ),
    )
    recipe = RecipeConfig(name="R1", sheets=[sheet])
    source = SourceConfig(path="src.xlsx", recipes=[recipe])
    gui.project = ProjectConfig(sources=[source])
    gui.refresh_tree()

    src = gui.tree.get_children()[0]
    rec = gui.tree.get_children(src)[0]
    sh = gui.tree.get_children(rec)[0]
    gui.tree.selection_set(sh)
    gui._on_tree_select()

    gui.add_rule()
    assert len(sheet.rules) == 1

    gui.destroy()


# ---- END {f} ----



# ---- BEGIN test_gui_sheet_editor.py ----

\
from core.project import ProjectConfig, SourceConfig, RecipeConfig
from core.models import SheetConfig, Destination
import gui.app as app


def test_sheet_selection_binds_editor_and_updates_model():
    gui = app.TurboExtractorApp()

    # Build simple project
    sheet = SheetConfig(
        name="Sheet1",
        workbook_sheet="Sheet1",
        columns_spec="A",
        rows_spec="1-1",
        paste_mode="pack",
        rules_combine="AND",
        rules=[],
        destination=Destination(
            file_path="out.xlsx",
            sheet_name="Out",
            start_col="B",
            start_row="",
        ),
    )
    recipe = RecipeConfig(name="R1", sheets=[sheet])
    source = SourceConfig(path="src.xlsx", recipes=[recipe])
    gui.project = ProjectConfig(sources=[source])

    gui.refresh_tree()

    # Select sheet node
    src_id = gui.tree.get_children()[0]
    recipe_id = gui.tree.get_children(src_id)[0]
    sheet_id = gui.tree.get_children(recipe_id)[0]

    gui.tree.selection_set(sheet_id)
    gui._on_tree_select()

    # Modify editor field
    gui.columns_var.set("A,C")
    assert sheet.columns_spec == "A,C"

    gui.destroy()


# ---- END {f} ----



# ---- BEGIN test_gui_tree_structure.py ----

\
import gui.app as app
from core.project import ProjectConfig, SourceConfig, RecipeConfig
from core.models import SheetConfig, Destination


def test_add_remove_structure_logic():
    gui = app.TurboExtractorApp()

    # manually create source
    sheet = SheetConfig(
        name="Sheet1",
        workbook_sheet="Sheet1",
        columns_spec="",
        rows_spec="",
        paste_mode="pack",
        rules_combine="AND",
        rules=[],
        destination=Destination(
            file_path="",
            sheet_name="Sheet1",
            start_col="A",
            start_row="",
        ),
    )
    recipe = RecipeConfig(name="Recipe1", sheets=[sheet])
    source = SourceConfig(path="src.xlsx", recipes=[recipe])
    gui.project = ProjectConfig(sources=[source])
    gui.refresh_tree()

    # remove sheet â†’ should auto-remove recipe
    src_id = gui.tree.get_children()[0]
    recipe_id = gui.tree.get_children(src_id)[0]
    sheet_id = gui.tree.get_children(recipe_id)[0]

    gui.tree.selection_set(sheet_id)
    gui.remove_selected()

    assert len(gui.project.sources[0].recipes) == 0

    gui.destroy()


# ---- END {f} ----

# ==================== END test_gui_consolidated.py ====================



# ==================== BEGIN test_gui_run_wiring.py ====================

import gui.app as app

from core.project import ProjectConfig, SourceConfig, RecipeConfig
from core.models import SheetConfig, Destination, SheetResult, RunReport


def test_run_all_calls_engine_with_project_items(monkeypatch):
    gui = app.TurboExtractorApp()

    sheet = SheetConfig(
        name="Sheet1",
        workbook_sheet="Sheet1",
        columns_spec="",
        rows_spec="",
        paste_mode="pack",
        rules_combine="AND",
        rules=[],
        destination=Destination(file_path="out.xlsx", sheet_name="Sheet1", start_col="A", start_row=""),
    )
    recipe = RecipeConfig(name="R1", sheets=[sheet])
    source = SourceConfig(path="src.xlsx", recipes=[recipe])
    gui.project = ProjectConfig(sources=[source])

    called = {}

    def fake_run_all(items):
        called["items"] = list(items)
        return RunReport(ok=True, results=[])

    monkeypatch.setattr(app, "engine_run_all", fake_run_all)
    monkeypatch.setattr(gui, "_show_scrollable_report_dialog", lambda *a, **k: None)

    gui.run_all()

    assert called["items"] == gui.project.build_run_items()
    gui.destroy()


def test_run_selected_sheet_calls_engine_with_current_context(monkeypatch):
    gui = app.TurboExtractorApp()

    sheet = SheetConfig(
        name="Sheet1",
        workbook_sheet="Sheet1",
        columns_spec="",
        rows_spec="",
        paste_mode="pack",
        rules_combine="AND",
        rules=[],
        destination=Destination(file_path="out.xlsx", sheet_name="Sheet1", start_col="A", start_row=""),
    )
    recipe = RecipeConfig(name="R1", sheets=[sheet])
    source = SourceConfig(path="src.xlsx", recipes=[recipe])
    gui.project = ProjectConfig(sources=[source])
    gui.refresh_tree()

    # Select sheet node to establish current context
    src_id = gui.tree.get_children()[0]
    recipe_id = gui.tree.get_children(src_id)[0]
    sheet_id = gui.tree.get_children(recipe_id)[0]
    gui.tree.selection_set(sheet_id)
    gui._on_tree_select()

    called = {}

    def fake_run_sheet(source_path, sheet_cfg, recipe_name="Recipe"):
        called["source_path"] = source_path
        called["sheet_cfg"] = sheet_cfg
        called["recipe_name"] = recipe_name
        return SheetResult(
            source_path=source_path,
            recipe_name=recipe_name,
            sheet_name=sheet_cfg.name,
            dest_file=sheet_cfg.destination.file_path,
            dest_sheet=sheet_cfg.destination.sheet_name,
            rows_written=7,
            message="OK",
        )

    monkeypatch.setattr(app, "engine_run_sheet", fake_run_sheet)
    monkeypatch.setattr(app.messagebox, "showinfo", lambda *a, **k: None)

    gui.run_selected_sheet()

    assert called["source_path"] == "src.xlsx"
    assert called["sheet_cfg"] is sheet
    assert called["recipe_name"] == "R1"
    gui.destroy()

# ==================== END test_gui_run_wiring.py ====================



# ==================== BEGIN test_gui_source_reorder.py ====================

import gui.app as app
from core.project import ProjectConfig, SourceConfig, RecipeConfig
from core.models import SheetConfig, Destination


def _make_source(path: str) -> SourceConfig:
    sheet = SheetConfig(
        name="Sheet1",
        workbook_sheet="Sheet1",
        columns_spec="",
        rows_spec="",
        paste_mode="pack",
        rules_combine="AND",
        rules=[],
        destination=Destination(file_path="", sheet_name="Sheet1", start_col="A", start_row=""),
    )
    recipe = RecipeConfig(name="Recipe1", sheets=[sheet])
    return SourceConfig(path=path, recipes=[recipe])


def test_move_source_up_and_down_reorders_project_and_tree():
    gui = app.TurboExtractorApp()

    s1 = _make_source("a.xlsx")
    s2 = _make_source("b.xlsx")
    gui.project = ProjectConfig(sources=[s1, s2])
    gui.refresh_tree()

    # Select second source
    src_ids = gui.tree.get_children("")
    assert len(src_ids) == 2
    gui.tree.selection_set(src_ids[1])
    gui._on_tree_select()

    gui.move_source_up()

    assert [s.path for s in gui.project.sources] == ["b.xlsx", "a.xlsx"]
    src_ids = gui.tree.get_children("")
    assert gui.tree.item(src_ids[0], "text") == "b.xlsx"

    # Move it back down
    gui.tree.selection_set(src_ids[0])
    gui._on_tree_select()

    gui.move_source_down()

    assert [s.path for s in gui.project.sources] == ["a.xlsx", "b.xlsx"]
    src_ids = gui.tree.get_children("")
    assert gui.tree.item(src_ids[1], "text") == "b.xlsx"

    gui.destroy()

# ==================== END test_gui_source_reorder.py ====================



# ==================== BEGIN test_gui_autosave.py ====================

import json
import os


def test_gui_autosave_writes_project(tmp_path, monkeypatch):
    autosave_path = tmp_path / "autosave.json"
    monkeypatch.setenv("TURBO_AUTOSAVE_PATH", str(autosave_path))

    from gui.app import TurboExtractorApp

    app = TurboExtractorApp()
    try:
        # Mutate project (no dialogs) and force-save
        app.project.sources.append(
            __import__("core.project", fromlist=["SourceConfig"]).SourceConfig(path="C:/x.csv", recipes=[])
        )
        app._mark_dirty()
        app._autosave_now()

        assert autosave_path.exists()
        data = json.loads(autosave_path.read_text(encoding="utf-8"))
        assert data["sources"][0]["path"] == "C:/x.csv"
    finally:
        app.destroy()


def test_gui_autoload_on_start(tmp_path, monkeypatch):
    autosave_path = tmp_path / "autosave.json"
    monkeypatch.setenv("TURBO_AUTOSAVE_PATH", str(autosave_path))

    from core.project import ProjectConfig, SourceConfig
    from core.autosave import save_project_atomic

    proj = ProjectConfig(sources=[SourceConfig(path="C:/a.xlsx", recipes=[])])
    save_project_atomic(proj, str(autosave_path))

    from gui.app import TurboExtractorApp

    app = TurboExtractorApp()
    try:
        assert len(app.project.sources) == 1
        assert app.project.sources[0].path == "C:/a.xlsx"
    finally:
        app.destroy()

# ==================== END test_gui_autosave.py ====================



# ==================== BEGIN test_gui_inline_rename.py ====================

import gui.app as app
from core.project import ProjectConfig, SourceConfig, RecipeConfig
from core.models import SheetConfig, Destination


def test_inline_rename_recipe_updates_model():
    gui = app.TurboExtractorApp()

    sheet = SheetConfig(
        name="Sheet1",
        workbook_sheet="Sheet1",
        columns_spec="",
        rows_spec="",
        paste_mode="pack",
        rules_combine="AND",
        rules=[],
        destination=Destination(file_path=""),
    )
    recipe = RecipeConfig(name="OldRecipe", sheets=[sheet])
    source = SourceConfig(path="src.xlsx", recipes=[recipe])
    gui.project = ProjectConfig(sources=[source])
    gui.refresh_tree()

    # Apply rename directly (commit path logic is UI; this is state edit)
    gui._apply_recipe_rename([0, 0], "NewRecipe")
    assert gui.project.sources[0].recipes[0].name == "NewRecipe"

    gui.destroy()


def test_inline_rename_sheet_updates_model_and_workbook_sheet():
    gui = app.TurboExtractorApp()

    sheet = SheetConfig(
        name="OldSheet",
        workbook_sheet="OldSheet",
        columns_spec="",
        rows_spec="",
        paste_mode="pack",
        rules_combine="AND",
        rules=[],
        destination=Destination(file_path=""),
    )
    recipe = RecipeConfig(name="R1", sheets=[sheet])
    source = SourceConfig(path="src.xlsx", recipes=[recipe])
    gui.project = ProjectConfig(sources=[source])
    gui.refresh_tree()

    gui._apply_sheet_rename([0, 0, 0], "NewSheetName")
    assert sheet.name == "NewSheetName"
    assert sheet.workbook_sheet == "NewSheetName"

    gui.destroy()

# ==================== END test_gui_inline_rename.py ====================



# ==================== BEGIN test_templates.py ====================

import os
from pathlib import Path

from core.models import Destination, Rule, SheetConfig
from core.project import ProjectConfig, SourceConfig, RecipeConfig
from core import templates as tpl


def _make_source(path: str) -> SourceConfig:
    sh = SheetConfig(
        name="SheetB",
        workbook_sheet="SheetB",
        source_start_row="4",
        columns_spec="A,C",
        rows_spec="1-3",
        paste_mode="keep",
        rules_combine="OR",
        rules=[Rule(mode="include", column="B", operator="contains", value="beta")],
        destination=Destination(file_path="out.xlsx", sheet_name="Dest", start_col="D", start_row=""),
    )
    r = RecipeConfig(name="RecipeX", sheets=[sh])
    return SourceConfig(path=path, recipes=[r])


def test_source_template_roundtrip_apply_does_not_change_path(tmp_path: Path):
    src1 = _make_source("/tmp/source1.xlsx")
    template = tpl.source_to_template(src1)

    # Save/load JSON
    p = tmp_path / "t.json"
    tpl.save_template_json(template, str(p))
    loaded = tpl.load_template_json(str(p))

    src2 = _make_source("/tmp/DIFFERENT.xlsx")
    src2.recipes = []
    tpl.apply_template_to_source(src2, loaded)

    assert src2.path == "/tmp/DIFFERENT.xlsx"  # path preserved
    assert len(src2.recipes) == 1
    assert src2.recipes[0].name == "RecipeX"
    assert src2.recipes[0].sheets[0].name == "SheetB"
    assert src2.recipes[0].sheets[0].source_start_row == "4"
    assert src2.recipes[0].sheets[0].destination.start_col == "D"
    assert src2.recipes[0].sheets[0].rules[0].operator == "contains"


def test_default_template_set_load_reset(tmp_path: Path, monkeypatch):
    src = _make_source("/tmp/source.xlsx")
    template = tpl.source_to_template(src)

    default_path = tmp_path / "default.json"
    monkeypatch.setenv(tpl.ENV_DEFAULT_TEMPLATE_PATH, str(default_path))

    assert tpl.load_default_template() is None
    saved_to = tpl.set_default_template(template)
    assert saved_to == str(default_path)
    assert tpl.load_default_template() is not None

    tpl.reset_default_template()
    assert tpl.load_default_template() is None

# ==================== END test_templates.py ====================



# ==================== BEGIN test_source_start_row.py ====================

from pathlib import Path

from openpyxl import Workbook, load_workbook

from core import engine
from core.models import Destination, SheetConfig
from core.project import ProjectConfig, SourceConfig, RecipeConfig


def _make_xlsx(path: Path) -> None:
    wb = Workbook()
    ws = wb.active
    ws.title = "Sheet1"
    # Row 1..5
    for i in range(1, 6):
        ws.cell(row=i, column=1, value=f"A{i}")
        ws.cell(row=i, column=2, value=f"B{i}")
    wb.save(path)


def test_source_start_row_offsets_rows_spec_and_all_rows(tmp_path: Path):
    src = tmp_path / "src.xlsx"
    out = tmp_path / "out.xlsx"
    _make_xlsx(src)

    # Start reading at source row 3; then rows_spec=1 means original row 3.
    sh = SheetConfig(
        name="Sheet1",
        workbook_sheet="Sheet1",
        source_start_row="3",
        columns_spec="A",
        rows_spec="1",
        paste_mode="pack",
        rules_combine="AND",
        rules=[],
        destination=Destination(file_path=str(out), sheet_name="Dest", start_col="A", start_row="1"),
    )

    res = engine.run_sheet(str(src), sh, recipe_name="R")
    assert res.rows_written == 1

    wb = load_workbook(out)
    ws = wb["Dest"]
    assert ws["A1"].value == "A3"

    # Now extract ALL rows from the trimmed table (rows 3..5)
    out2 = tmp_path / "out2.xlsx"
    sh.destination.file_path = str(out2)
    sh.rows_spec = ""  # ALL rows (relative to trimmed)
    res2 = engine.run_sheet(str(src), sh, recipe_name="R")
    assert res2.rows_written == 3

    wb2 = load_workbook(out2)
    ws2 = wb2["Dest"]
    assert [ws2[f"A{i}"].value for i in range(1, 4)] == ["A3", "A4", "A5"]


def test_project_json_roundtrip_preserves_source_start_row(tmp_path: Path):
    sh = SheetConfig(
        name="Sheet1",
        workbook_sheet="Sheet1",
        source_start_row="7",
        columns_spec="A",
        rows_spec="",
        paste_mode="pack",
        rules_combine="AND",
        rules=[],
        destination=Destination(file_path="out.xlsx", sheet_name="Dest", start_col="A", start_row=""),
    )

    proj = ProjectConfig(
        sources=[
            SourceConfig(
                path="/tmp/source.xlsx",
                recipes=[RecipeConfig(name="Recipe1", sheets=[sh])],
            )
        ]
    )

    p = tmp_path / "proj.json"
    proj.save_json(str(p))

    loaded = ProjectConfig.load_json(str(p))
    assert loaded.sources[0].recipes[0].sheets[0].source_start_row == "7"

# ==================== END test_source_start_row.py ====================



# ==================== BEGIN test_import_resolution.py ====================

def test_core_import():
    import core.engine
    import core.planner
    import core.writer
    import core.models
    import core.errors

def test_gui_import():
    import gui.app

# ==================== END test_import_resolution.py ====================
